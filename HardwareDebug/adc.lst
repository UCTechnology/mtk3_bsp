   1                             		.file	"adc.c"
   2                             		.section P,"ax"
   3                             	.Ltext0:
   4                             		.local	_dev_adc_cb
   5                             		.comm	_dev_adc_cb,8,4
   7                             	_read_atr:
   8                             	.LFB6:
   9                             		.file 1 "../device/adc/adc.c"
   1:../device/adc/adc.c **** /*
   2:../device/adc/adc.c ****  *----------------------------------------------------------------------
   3:../device/adc/adc.c ****  *    Device Driver for Î¼T-Kernel 3.0
   4:../device/adc/adc.c ****  *
   5:../device/adc/adc.c ****  *    Copyright (C) 2020-2022 by Ken Sakamura.
   6:../device/adc/adc.c ****  *    This software is distributed under the T-License 2.2.
   7:../device/adc/adc.c ****  *----------------------------------------------------------------------
   8:../device/adc/adc.c ****  *
   9:../device/adc/adc.c ****  *    Released by TRON Forum(http://www.tron.org) at 2022/02.
  10:../device/adc/adc.c ****  *
  11:../device/adc/adc.c ****  *----------------------------------------------------------------------
  12:../device/adc/adc.c ****  */
  13:../device/adc/adc.c **** #include <sys/machine.h>
  14:../device/adc/adc.c **** #include <tk/tkernel.h>
  15:../device/adc/adc.c **** #include <tstdlib.h>
  16:../device/adc/adc.c **** 
  17:../device/adc/adc.c **** #include "adc.h"
  18:../device/adc/adc.c **** #include "../include/dev_def.h"
  19:../device/adc/adc.c **** #if DEV_ADC_ENABLE
  20:../device/adc/adc.c **** /*
  21:../device/adc/adc.c ****  *	adc.c
  22:../device/adc/adc.c ****  *	A/D converter device driver 
  23:../device/adc/adc.c **** */
  24:../device/adc/adc.c **** 
  25:../device/adc/adc.c **** /*----------------------------------------------------------------------*/
  26:../device/adc/adc.c **** /* Device driver Control block
  27:../device/adc/adc.c ****  */
  28:../device/adc/adc.c **** #if TK_SUPPORT_MEMLIB
  29:../device/adc/adc.c **** 
  30:../device/adc/adc.c **** LOCAL T_ADC_DCB	*dev_adc_cb[DEV_ADC_UNITNM];
  31:../device/adc/adc.c **** #define		get_dcb_ptr(unit)	(dev_adc_cb[unit])
  32:../device/adc/adc.c **** #define		get_dcb_mem(unit,a)	(dev_adc_cb[unit]->a)
  33:../device/adc/adc.c **** 
  34:../device/adc/adc.c **** #else
  35:../device/adc/adc.c **** 
  36:../device/adc/adc.c **** LOCAL T_ADC_DCB	dev_adc_cb[DEV_ADC_UNITNM];
  37:../device/adc/adc.c **** #define		get_dcb_ptr(unit)	(&dev_adc_cb[unit])
  38:../device/adc/adc.c **** #define		get_dcb_mem(unit,a)	(dev_adc_cb[unit].a)
  39:../device/adc/adc.c **** 
  40:../device/adc/adc.c **** #endif	/* TK_SUPPORT_MEMLIB */
  41:../device/adc/adc.c **** 
  42:../device/adc/adc.c **** /*----------------------------------------------------------------------*/
  43:../device/adc/adc.c **** /* Attribute data control
  44:../device/adc/adc.c ****  */
  45:../device/adc/adc.c **** LOCAL ER read_atr(T_ADC_DCB *p_dcb, T_DEVREQ *req)
  46:../device/adc/adc.c **** {
  10                             		.loc 1 46 1
  11 0000 7E AA                   		push.l	r10
  12                             	.LCFI0:
  13 0002 71 0A F4                		add	#-12, r0, r10
  14                             	.LCFI1:
  15 0005 EF A0                   		mov.L	r10, r0
  16 0007 E7 A1 01                		mov.L	r1, 4[r10]
  17 000a E7 A2 02                		mov.L	r2, 8[r10]
  47:../device/adc/adc.c **** 	ER	err	= E_OK;
  18                             		.loc 1 47 5
  19 000d F8 A6 00                		mov.L	#0, [r10]
  48:../device/adc/adc.c **** 
  49:../device/adc/adc.c **** 	switch(req->start) {
  20                             		.loc 1 49 12
  21 0010 ED A5 02                		mov.L	8[r10], r5
  22 0013 A9 55                   		mov.L	16[r5], r5
  23                             		.loc 1 49 2
  24 0015 75 05 FF                		cmp	#-1, r5
  25 0018 21 2D                   		bne	.L2
  50:../device/adc/adc.c **** 	case TDN_EVENT:			/* MBF ID for event notification */
  51:../device/adc/adc.c **** 		if(req->size >= sizeof(ID)) {
  26                             		.loc 1 51 9
  27 001a ED A5 02                		mov.L	8[r10], r5
  28 001d A9 5D                   		mov.L	20[r5], r5
  29                             		.loc 1 51 5
  30 001f 61 35                   		cmp	#3, r5
  31 0021 25 10                   		bleu	.L3
  52:../device/adc/adc.c **** 			*(ID*)req->buf = p_dcb->evtmbfid;
  32                             		.loc 1 52 13
  33 0023 ED A5 02                		mov.L	8[r10], r5
  34 0026 A9 D5                   		mov.L	24[r5], r5
  35                             		.loc 1 52 26
  36 0028 ED A4 01                		mov.L	4[r10], r4
  37 002b A8 C4                   		mov.L	8[r4], r4
  38                             		.loc 1 52 19
  39 002d E3 54                   		mov.L	r4, [r5]
  40 002f 2E 0F                   		bra	.L4
  41                             	.L3:
  53:../device/adc/adc.c **** 		} else if(req->size != 0) {
  42                             		.loc 1 53 16
  43 0031 ED A5 02                		mov.L	8[r10], r5
  44 0034 A9 5D                   		mov.L	20[r5], r5
  45                             		.loc 1 53 12
  46 0036 61 05                   		cmp	#0, r5
  47 0038 16                      		beq	.L4
  54:../device/adc/adc.c **** 			err = E_PAR;
  48                             		.loc 1 54 8
  49 0039 F8 A6 EF                		mov.L	#-17, [r10]
  55:../device/adc/adc.c **** 			break;
  50                             		.loc 1 55 4
  51 003c 2E 0D                   		bra	.L5
  52                             	.L4:
  56:../device/adc/adc.c **** 		}
  57:../device/adc/adc.c **** 		req->asize = sizeof(ID);
  53                             		.loc 1 57 14
  54 003e ED A5 02                		mov.L	8[r10], r5
  55 0041 3E 57 04                		mov.L	#4, 28[r5]
  58:../device/adc/adc.c **** 		break;
  56                             		.loc 1 58 3
  57 0044 0D                      		bra	.L5
  58                             	.L2:
  59:../device/adc/adc.c **** 	default:
  60:../device/adc/adc.c **** 		err = E_PAR;
  59                             		.loc 1 60 7
  60 0045 F8 A6 EF                		mov.L	#-17, [r10]
  61:../device/adc/adc.c **** 		break;
  61                             		.loc 1 61 3
  62 0048 03                      		nop
  63                             	.L5:
  62:../device/adc/adc.c **** 	}
  63:../device/adc/adc.c **** 
  64:../device/adc/adc.c **** 	return err;
  64                             		.loc 1 64 9
  65 0049 EC A5                   		mov.L	[r10], r5
  65:../device/adc/adc.c **** }
  66                             		.loc 1 65 1
  67 004b EF 51                   		mov.L	r5, r1
  68 004d 3F AA 04                		rtsd	#16, r10-r10
  69                             	.LFE6:
  72                             	_write_atr:
  73                             	.LFB7:
  66:../device/adc/adc.c **** 
  67:../device/adc/adc.c **** 
  68:../device/adc/adc.c **** LOCAL ER write_atr(T_ADC_DCB *p_dcb, T_DEVREQ *req)
  69:../device/adc/adc.c **** {
  74                             		.loc 1 69 1
  75 0050 7E AA                   		push.l	r10
  76                             	.LCFI2:
  77 0052 71 0A F4                		add	#-12, r0, r10
  78                             	.LCFI3:
  79 0055 EF A0                   		mov.L	r10, r0
  80 0057 E7 A1 01                		mov.L	r1, 4[r10]
  81 005a E7 A2 02                		mov.L	r2, 8[r10]
  70:../device/adc/adc.c **** 	ER	err	= E_OK;
  82                             		.loc 1 70 5
  83 005d F8 A6 00                		mov.L	#0, [r10]
  71:../device/adc/adc.c **** 
  72:../device/adc/adc.c **** 	switch(req->start) {
  84                             		.loc 1 72 12
  85 0060 ED A5 02                		mov.L	8[r10], r5
  86 0063 A9 55                   		mov.L	16[r5], r5
  87                             		.loc 1 72 2
  88 0065 75 05 FF                		cmp	#-1, r5
  89 0068 21 2D                   		bne	.L8
  73:../device/adc/adc.c **** 	case TDN_EVENT:			/* MBF ID for event notification */
  74:../device/adc/adc.c **** 		if(req->size >= sizeof(ID)) {
  90                             		.loc 1 74 9
  91 006a ED A5 02                		mov.L	8[r10], r5
  92 006d A9 5D                   		mov.L	20[r5], r5
  93                             		.loc 1 74 5
  94 006f 61 35                   		cmp	#3, r5
  95 0071 25 10                   		bleu	.L9
  75:../device/adc/adc.c **** 			p_dcb->evtmbfid = *(ID*)req->buf;
  96                             		.loc 1 75 31
  97 0073 ED A5 02                		mov.L	8[r10], r5
  98 0076 A9 D5                   		mov.L	24[r5], r5
  99                             		.loc 1 75 22
 100 0078 EC 54                   		mov.L	[r5], r4
 101                             		.loc 1 75 20
 102 007a ED A5 01                		mov.L	4[r10], r5
 103 007d A0 D4                   		mov.L	r4, 8[r5]
 104 007f 2E 0F                   		bra	.L10
 105                             	.L9:
  76:../device/adc/adc.c **** 		} else if(req->size != 0) {
 106                             		.loc 1 76 16
 107 0081 ED A5 02                		mov.L	8[r10], r5
 108 0084 A9 5D                   		mov.L	20[r5], r5
 109                             		.loc 1 76 12
 110 0086 61 05                   		cmp	#0, r5
 111 0088 16                      		beq	.L10
  77:../device/adc/adc.c **** 			err = E_PAR;
 112                             		.loc 1 77 8
 113 0089 F8 A6 EF                		mov.L	#-17, [r10]
  78:../device/adc/adc.c **** 			break;
 114                             		.loc 1 78 4
 115 008c 2E 0D                   		bra	.L11
 116                             	.L10:
  79:../device/adc/adc.c **** 		}
  80:../device/adc/adc.c **** 		req->asize = sizeof(ID);
 117                             		.loc 1 80 14
 118 008e ED A5 02                		mov.L	8[r10], r5
 119 0091 3E 57 04                		mov.L	#4, 28[r5]
  81:../device/adc/adc.c **** 		break;
 120                             		.loc 1 81 3
 121 0094 0D                      		bra	.L11
 122                             	.L8:
  82:../device/adc/adc.c **** 	default:
  83:../device/adc/adc.c **** 		err = E_PAR;
 123                             		.loc 1 83 7
 124 0095 F8 A6 EF                		mov.L	#-17, [r10]
  84:../device/adc/adc.c **** 		break;
 125                             		.loc 1 84 3
 126 0098 03                      		nop
 127                             	.L11:
  85:../device/adc/adc.c **** 	}
  86:../device/adc/adc.c **** 
  87:../device/adc/adc.c **** 	return err;
 128                             		.loc 1 87 9
 129 0099 EC A5                   		mov.L	[r10], r5
  88:../device/adc/adc.c **** }
 130                             		.loc 1 88 1
 131 009b EF 51                   		mov.L	r5, r1
 132 009d 3F AA 04                		rtsd	#16, r10-r10
 133                             	.LFE7:
 136                             	_read_data:
 137                             	.LFB8:
  89:../device/adc/adc.c **** 
  90:../device/adc/adc.c **** /*----------------------------------------------------------------------*/
  91:../device/adc/adc.c **** /* Device-specific data control
  92:../device/adc/adc.c ****  */
  93:../device/adc/adc.c **** LOCAL ER read_data(T_ADC_DCB *p_dcb, T_DEVREQ *req)
  94:../device/adc/adc.c **** {
 138                             		.loc 1 94 1
 139 00a0 7E AA                   		push.l	r10
 140                             	.LCFI4:
 141 00a2 71 0A F0                		add	#-16, r0, r10
 142                             	.LCFI5:
 143 00a5 71 A0 FC                		add	#-4, r10, r0
 144                             	.LCFI6:
 145 00a8 E7 A1 02                		mov.L	r1, 8[r10]
 146 00ab E7 A2 03                		mov.L	r2, 12[r10]
  95:../device/adc/adc.c **** 	W	rtn;
  96:../device/adc/adc.c **** 	ER	err = E_OK;
 147                             		.loc 1 96 5
 148 00ae F8 A6 00                		mov.L	#0, [r10]
  97:../device/adc/adc.c **** 
  98:../device/adc/adc.c **** 	if(req->size) {
 149                             		.loc 1 98 8
 150 00b1 ED A5 03                		mov.L	12[r10], r5
 151 00b4 A9 5D                   		mov.L	20[r5], r5
 152                             		.loc 1 98 4
 153 00b6 61 05                   		cmp	#0, r5
 154 00b8 20 4C                   		beq	.L14
  99:../device/adc/adc.c **** 		rtn = dev_adc_llctl( p_dcb->unit, LLD_ADC_READ, req->start, req->size, req->buf);
 155                             		.loc 1 99 9
 156 00ba ED A5 02                		mov.L	8[r10], r5
 157 00bd EC 51                   		mov.L	[r5], r1
 158                             		.loc 1 99 54
 159 00bf ED A5 03                		mov.L	12[r10], r5
 160 00c2 A9 55                   		mov.L	16[r5], r5
 161                             		.loc 1 99 9
 162 00c4 EF 53                   		mov.L	r5, r3
 163                             		.loc 1 99 66
 164 00c6 ED A5 03                		mov.L	12[r10], r5
 165 00c9 A9 5D                   		mov.L	20[r5], r5
 166                             		.loc 1 99 9
 167 00cb EF 54                   		mov.L	r5, r4
 168                             		.loc 1 99 77
 169 00cd ED A5 03                		mov.L	12[r10], r5
 170 00d0 A9 D5                   		mov.L	24[r5], r5
 171                             		.loc 1 99 9
 172 00d2 E3 05                   		mov.L	r5, [r0]
 173 00d4 66 22                   		mov.L	#2, r2
 174 00d6 05 00 00 00             		bsr	_dev_adc_llctl
 175 00da E7 A1 01                		mov.L	r1, 4[r10]
 100:../device/adc/adc.c **** 		if(rtn > 0) {
 176                             		.loc 1 100 5
 177 00dd ED A5 01                		mov.L	4[r10], r5
 178 00e0 61 05                   		cmp	#0, r5
 179 00e2 2B 1B                   		ble	.L15
 101:../device/adc/adc.c **** 			req->asize = rtn;
 180                             		.loc 1 101 15
 181 00e4 ED A5 03                		mov.L	12[r10], r5
 182 00e7 ED A4 01                		mov.L	4[r10], r4
 183 00ea A1 DC                   		mov.L	r4, 28[r5]
 102:../device/adc/adc.c **** 			if(req->size != rtn) err = E_IO;
 184                             		.loc 1 102 10
 185 00ec ED A5 03                		mov.L	12[r10], r5
 186 00ef A9 5D                   		mov.L	20[r5], r5
 187                             		.loc 1 102 6
 188 00f1 ED A4 01                		mov.L	4[r10], r4
 189 00f4 47 54                   		cmp	r5, r4
 190 00f6 20 2C                   		beq	.L18
 191                             		.loc 1 102 29 discriminator 1
 192 00f8 F8 A6 C7                		mov.L	#-57, [r10]
 193 00fb 2E 27                   		bra	.L18
 194                             	.L15:
 103:../device/adc/adc.c **** 		} else {
 104:../device/adc/adc.c **** 			err = (ER)rtn;
 195                             		.loc 1 104 8
 196 00fd ED A5 01                		mov.L	4[r10], r5
 197 0100 E3 A5                   		mov.L	r5, [r10]
 198 0102 2E 20                   		bra	.L18
 199                             	.L14:
 105:../device/adc/adc.c **** 		}
 106:../device/adc/adc.c **** 	} else {
 107:../device/adc/adc.c **** 		req->asize = dev_adc_llctl( p_dcb->unit, LLD_ADC_RSIZE, req->start, 0, 0);
 200                             		.loc 1 107 16
 201 0104 ED A5 02                		mov.L	8[r10], r5
 202 0107 EC 51                   		mov.L	[r5], r1
 203                             		.loc 1 107 62
 204 0109 ED A5 03                		mov.L	12[r10], r5
 205 010c A9 55                   		mov.L	16[r5], r5
 206                             		.loc 1 107 16
 207 010e F8 06 00                		mov.L	#0, [r0]
 208 0111 66 04                   		mov.L	#0, r4
 209 0113 EF 53                   		mov.L	r5, r3
 210 0115 66 32                   		mov.L	#3, r2
 211 0117 05 00 00 00             		bsr	_dev_adc_llctl
 212 011b EF 14                   		mov.L	r1, r4
 213                             		.loc 1 107 14
 214 011d ED A5 03                		mov.L	12[r10], r5
 215 0120 A1 DC                   		mov.L	r4, 28[r5]
 216                             		.balign 8,3,1
 217                             	.L18:
 108:../device/adc/adc.c **** 	}
 109:../device/adc/adc.c **** 
 110:../device/adc/adc.c **** 	return err;
 218                             		.loc 1 110 9
 219 0122 EC A5                   		mov.L	[r10], r5
 111:../device/adc/adc.c **** }
 220                             		.loc 1 111 1
 221 0124 EF 51                   		mov.L	r5, r1
 222 0126 3F AA 06                		rtsd	#24, r10-r10
 223                             	.LFE8:
 225                             		.global	_dev_adc_openfn
 227                             	_dev_adc_openfn:
 228                             	.LFB9:
 112:../device/adc/adc.c **** 
 113:../device/adc/adc.c **** 
 114:../device/adc/adc.c **** /*----------------------------------------------------------------------
 115:../device/adc/adc.c ****  * mSDI I/F function
 116:../device/adc/adc.c ****  */
 117:../device/adc/adc.c **** /*----------------------------------------------------------------------
 118:../device/adc/adc.c ****  * Open device
 119:../device/adc/adc.c ****  */
 120:../device/adc/adc.c **** ER dev_adc_openfn( ID devid, UINT omode, T_MSDI *msdi)
 121:../device/adc/adc.c **** {
 229                             		.loc 1 121 1
 230 0129 7E AA                   		push.l	r10
 231                             	.LCFI7:
 232 012b 71 0A EC                		add	#-20, r0, r10
 233                             	.LCFI8:
 234 012e 71 A0 FC                		add	#-4, r10, r0
 235                             	.LCFI9:
 236 0131 E7 A1 02                		mov.L	r1, 8[r10]
 237 0134 E7 A2 03                		mov.L	r2, 12[r10]
 238 0137 E7 A3 04                		mov.L	r3, 16[r10]
 122:../device/adc/adc.c **** 	T_ADC_DCB	*p_dcb;
 123:../device/adc/adc.c **** 	ER		err;
 124:../device/adc/adc.c **** 
 125:../device/adc/adc.c **** 	p_dcb = (T_ADC_DCB*)(msdi->dmsdi.exinf);
 239                             		.loc 1 125 8
 240 013a ED A5 04                		mov.L	16[r10], r5
 241 013d A9 55                   		mov.L	16[r5], r5
 242 013f E3 A5                   		mov.L	r5, [r10]
 126:../device/adc/adc.c **** 
 127:../device/adc/adc.c **** 	/* Device Open operation */
 128:../device/adc/adc.c **** 	p_dcb->omode = omode;
 243                             		.loc 1 128 15
 244 0141 EC A5                   		mov.L	[r10], r5
 245 0143 ED A4 03                		mov.L	12[r10], r4
 246 0146 A0 5C                   		mov.L	r4, 4[r5]
 129:../device/adc/adc.c **** 	err = (ER)dev_adc_llctl( p_dcb->unit, LLD_ADC_OPEN, 0, 0, 0);
 247                             		.loc 1 129 12
 248 0148 EC A5                   		mov.L	[r10], r5
 249 014a EC 55                   		mov.L	[r5], r5
 250 014c F8 06 00                		mov.L	#0, [r0]
 251 014f 66 04                   		mov.L	#0, r4
 252 0151 66 03                   		mov.L	#0, r3
 253 0153 66 02                   		mov.L	#0, r2
 254 0155 EF 51                   		mov.L	r5, r1
 255 0157 05 00 00 00             		bsr	_dev_adc_llctl
 256 015b E7 A1 01                		mov.L	r1, 4[r10]
 130:../device/adc/adc.c **** 
 131:../device/adc/adc.c **** 	return err;
 257                             		.loc 1 131 9
 258 015e ED A5 01                		mov.L	4[r10], r5
 132:../device/adc/adc.c **** }
 259                             		.loc 1 132 1
 260 0161 EF 51                   		mov.L	r5, r1
 261 0163 3F AA 07                		rtsd	#28, r10-r10
 262                             	.LFE9:
 264                             		.global	_dev_adc_closefn
 266                             	_dev_adc_closefn:
 267                             	.LFB10:
 133:../device/adc/adc.c **** 
 134:../device/adc/adc.c **** /*----------------------------------------------------------------------
 135:../device/adc/adc.c ****  * Close Device
 136:../device/adc/adc.c ****  */
 137:../device/adc/adc.c **** ER dev_adc_closefn( ID devid, UINT option, T_MSDI *msdi)
 138:../device/adc/adc.c **** {
 268                             		.loc 1 138 1
 269 0166 7E AA                   		push.l	r10
 270                             	.LCFI10:
 271 0168 71 0A EC                		add	#-20, r0, r10
 272                             	.LCFI11:
 273 016b 71 A0 FC                		add	#-4, r10, r0
 274                             	.LCFI12:
 275 016e E7 A1 02                		mov.L	r1, 8[r10]
 276 0171 E7 A2 03                		mov.L	r2, 12[r10]
 277 0174 E7 A3 04                		mov.L	r3, 16[r10]
 139:../device/adc/adc.c **** 	T_ADC_DCB	*p_dcb;
 140:../device/adc/adc.c **** 	ER		err;
 141:../device/adc/adc.c **** 
 142:../device/adc/adc.c **** 	p_dcb = (T_ADC_DCB*)(msdi->dmsdi.exinf);
 278                             		.loc 1 142 8
 279 0177 ED A5 04                		mov.L	16[r10], r5
 280 017a A9 55                   		mov.L	16[r5], r5
 281 017c E3 A5                   		mov.L	r5, [r10]
 143:../device/adc/adc.c **** 
 144:../device/adc/adc.c **** 	/* Device Close operation */
 145:../device/adc/adc.c **** 	err =(ER)dev_adc_llctl( p_dcb->unit, LLD_ADC_CLOSE, 0, 0, 0);
 282                             		.loc 1 145 11
 283 017e EC A5                   		mov.L	[r10], r5
 284 0180 EC 55                   		mov.L	[r5], r5
 285 0182 F8 06 00                		mov.L	#0, [r0]
 286 0185 66 04                   		mov.L	#0, r4
 287 0187 66 03                   		mov.L	#0, r3
 288 0189 66 12                   		mov.L	#1, r2
 289 018b EF 51                   		mov.L	r5, r1
 290 018d 05 00 00 00             		bsr	_dev_adc_llctl
 291 0191 E7 A1 01                		mov.L	r1, 4[r10]
 146:../device/adc/adc.c **** 	
 147:../device/adc/adc.c **** 	return err;
 292                             		.loc 1 147 9
 293 0194 ED A5 01                		mov.L	4[r10], r5
 148:../device/adc/adc.c **** }
 294                             		.loc 1 148 1
 295 0197 EF 51                   		mov.L	r5, r1
 296 0199 3F AA 07                		rtsd	#28, r10-r10
 297                             	.LFE10:
 299                             		.global	_dev_adc_readfn
 301                             	_dev_adc_readfn:
 302                             	.LFB11:
 149:../device/adc/adc.c **** 
 150:../device/adc/adc.c **** /*----------------------------------------------------------------------
 151:../device/adc/adc.c ****  * Read Device
 152:../device/adc/adc.c ****  */
 153:../device/adc/adc.c **** ER dev_adc_readfn( T_DEVREQ *req, T_MSDI *p_msdi)
 154:../device/adc/adc.c **** {
 303                             		.loc 1 154 1
 304 019c 7E AA                   		push.l	r10
 305                             	.LCFI13:
 306 019e 71 0A F0                		add	#-16, r0, r10
 307                             	.LCFI14:
 308 01a1 EF A0                   		mov.L	r10, r0
 309 01a3 E7 A1 02                		mov.L	r1, 8[r10]
 310 01a6 E7 A2 03                		mov.L	r2, 12[r10]
 155:../device/adc/adc.c **** 	T_ADC_DCB	*p_dcb;
 156:../device/adc/adc.c **** 	ER		err;
 157:../device/adc/adc.c **** 
 158:../device/adc/adc.c **** 	p_dcb = (T_ADC_DCB*)(p_msdi->dmsdi.exinf);
 311                             		.loc 1 158 8
 312 01a9 ED A5 03                		mov.L	12[r10], r5
 313 01ac A9 55                   		mov.L	16[r5], r5
 314 01ae E7 A5 01                		mov.L	r5, 4[r10]
 159:../device/adc/adc.c **** 
 160:../device/adc/adc.c **** 	if(req->start >= 0) {	// Device specific data
 315                             		.loc 1 160 8
 316 01b1 ED A5 02                		mov.L	8[r10], r5
 317 01b4 A9 55                   		mov.L	16[r5], r5
 318                             		.loc 1 160 4
 319 01b6 61 05                   		cmp	#0, r5
 320 01b8 29 1F                   		blt	.L25
 161:../device/adc/adc.c **** 		if( p_dcb->omode & TD_READ ) {
 321                             		.loc 1 161 12
 322 01ba ED A5 01                		mov.L	4[r10], r5
 323 01bd A8 5D                   		mov.L	4[r5], r5
 324                             		.loc 1 161 20
 325 01bf 64 15                   		and	#1, r5
 326                             		.loc 1 161 5
 327 01c1 61 05                   		cmp	#0, r5
 328 01c3 20 0F                   		beq	.L26
 162:../device/adc/adc.c **** 			err = read_data( p_dcb, req);
 329                             		.loc 1 162 10
 330 01c5 ED A2 02                		mov.L	8[r10], r2
 331 01c8 ED A1 01                		mov.L	4[r10], r1
 332 01cb 39 D5 FE                		bsr	_read_data
 333 01ce E3 A1                   		mov.L	r1, [r10]
 334 01d0 2E 12                   		bra	.L28
 335                             	.L26:
 163:../device/adc/adc.c **** 		} else {
 164:../device/adc/adc.c **** 			err = E_OACV;
 336                             		.loc 1 164 8
 337 01d2 F8 A6 E5                		mov.L	#-27, [r10]
 338 01d5 2E 0D                   		bra	.L28
 339                             	.L25:
 165:../device/adc/adc.c **** 		}
 166:../device/adc/adc.c **** 	} else {		// Device attribute data
 167:../device/adc/adc.c **** 		err = read_atr( p_dcb, req);
 340                             		.loc 1 167 9
 341 01d7 ED A2 02                		mov.L	8[r10], r2
 342 01da ED A1 01                		mov.L	4[r10], r1
 343 01dd 39 23 FE                		bsr	_read_atr
 344 01e0 E3 A1                   		mov.L	r1, [r10]
 345                             	.L28:
 168:../device/adc/adc.c **** 	}
 169:../device/adc/adc.c **** 
 170:../device/adc/adc.c **** 	return err;
 346                             		.loc 1 170 9
 347 01e2 EC A5                   		mov.L	[r10], r5
 171:../device/adc/adc.c **** }
 348                             		.loc 1 171 1
 349 01e4 EF 51                   		mov.L	r5, r1
 350 01e6 3F AA 05                		rtsd	#20, r10-r10
 351                             	.LFE11:
 353                             		.global	_dev_adc_writefn
 355                             	_dev_adc_writefn:
 356                             	.LFB12:
 172:../device/adc/adc.c **** 
 173:../device/adc/adc.c **** /*----------------------------------------------------------------------
 174:../device/adc/adc.c ****  * Write Device
 175:../device/adc/adc.c ****  */
 176:../device/adc/adc.c **** ER dev_adc_writefn( T_DEVREQ *req, T_MSDI *p_msdi)
 177:../device/adc/adc.c **** {
 357                             		.loc 1 177 1
 358 01e9 7E AA                   		push.l	r10
 359                             	.LCFI15:
 360 01eb 71 0A F0                		add	#-16, r0, r10
 361                             	.LCFI16:
 362 01ee EF A0                   		mov.L	r10, r0
 363 01f0 E7 A1 02                		mov.L	r1, 8[r10]
 364 01f3 E7 A2 03                		mov.L	r2, 12[r10]
 178:../device/adc/adc.c **** 	T_ADC_DCB	*p_dcb;
 179:../device/adc/adc.c **** 	ER		err;
 180:../device/adc/adc.c **** 
 181:../device/adc/adc.c **** 	p_dcb = (T_ADC_DCB*)(p_msdi->dmsdi.exinf);
 365                             		.loc 1 181 8
 366 01f6 ED A5 03                		mov.L	12[r10], r5
 367 01f9 A9 55                   		mov.L	16[r5], r5
 368 01fb E7 A5 01                		mov.L	r5, 4[r10]
 182:../device/adc/adc.c **** 
 183:../device/adc/adc.c **** 	if(req->start >= 0) {	// Device specific data
 369                             		.loc 1 183 8
 370 01fe ED A5 02                		mov.L	8[r10], r5
 371 0201 A9 55                   		mov.L	16[r5], r5
 372                             		.loc 1 183 4
 373 0203 61 05                   		cmp	#0, r5
 374 0205 29 07                   		blt	.L31
 184:../device/adc/adc.c **** 		err = E_PAR;
 375                             		.loc 1 184 7
 376 0207 F8 A6 EF                		mov.L	#-17, [r10]
 377 020a 2E 0D                   		bra	.L32
 378                             	.L31:
 185:../device/adc/adc.c **** 	} else {		// Device attribute data
 186:../device/adc/adc.c **** 		err = write_atr( p_dcb, req);
 379                             		.loc 1 186 9
 380 020c ED A2 02                		mov.L	8[r10], r2
 381 020f ED A1 01                		mov.L	4[r10], r1
 382 0212 39 3E FE                		bsr	_write_atr
 383 0215 E3 A1                   		mov.L	r1, [r10]
 384                             	.L32:
 187:../device/adc/adc.c **** 	}
 188:../device/adc/adc.c **** 
 189:../device/adc/adc.c **** 	return err;
 385                             		.loc 1 189 9
 386 0217 EC A5                   		mov.L	[r10], r5
 190:../device/adc/adc.c **** }
 387                             		.loc 1 190 1
 388 0219 EF 51                   		mov.L	r5, r1
 389 021b 3F AA 05                		rtsd	#20, r10-r10
 390                             	.LFE12:
 392                             		.global	_dev_adc_eventfn
 394                             	_dev_adc_eventfn:
 395                             	.LFB13:
 191:../device/adc/adc.c **** 
 192:../device/adc/adc.c **** /*----------------------------------------------------------------------
 193:../device/adc/adc.c ****  * Event Device
 194:../device/adc/adc.c ****  */
 195:../device/adc/adc.c **** ER dev_adc_eventfn( INT evttyp, void *evtinf, T_MSDI *msdi)
 196:../device/adc/adc.c **** {
 396                             		.loc 1 196 1
 397 021e 7E AA                   		push.l	r10
 398                             	.LCFI17:
 399 0220 71 0A F4                		add	#-12, r0, r10
 400                             	.LCFI18:
 401 0223 EF A0                   		mov.L	r10, r0
 402 0225 E3 A1                   		mov.L	r1, [r10]
 403 0227 E7 A2 01                		mov.L	r2, 4[r10]
 404 022a E7 A3 02                		mov.L	r3, 8[r10]
 197:../device/adc/adc.c **** 	return E_NOSPT;
 405                             		.loc 1 197 9
 406 022d FB 56 F7                		mov.L	#-9, r5
 198:../device/adc/adc.c **** }
 407                             		.loc 1 198 1
 408 0230 EF 51                   		mov.L	r5, r1
 409 0232 3F AA 04                		rtsd	#16, r10-r10
 410                             	.LFE13:
 412                             		.section C,"a",@progbits
 413                             		.p2align 2
 414                             	.LC0:
 415 0000 61 64 63 00             		.string	"adc"
 416                             		.section P,"ax"
 417                             		.global	_dev_init_adc
 419                             	_dev_init_adc:
 420                             	.LFB14:
 199:../device/adc/adc.c **** 
 200:../device/adc/adc.c **** /*----------------------------------------------------------------------
 201:../device/adc/adc.c ****  * Device driver initialization and registration
 202:../device/adc/adc.c ****  */
 203:../device/adc/adc.c **** EXPORT ER dev_init_adc( UW unit )
 204:../device/adc/adc.c **** {
 421                             		.loc 1 204 1
 422 0235 7E AA                   		push.l	r10
 423                             	.LCFI19:
 424 0237 71 0A B4                		add	#-76, r0, r10
 425                             	.LCFI20:
 426 023a EF A0                   		mov.L	r10, r0
 427 023c E7 A1 12                		mov.L	r1, 72[r10]
 205:../device/adc/adc.c **** 	T_ADC_DCB	*p_dcb;
 206:../device/adc/adc.c **** 	T_IDEV		idev;
 207:../device/adc/adc.c **** 	T_MSDI		*p_msdi;
 208:../device/adc/adc.c **** 	T_DMSDI		dmsdi;
 209:../device/adc/adc.c **** 	ER		err;
 210:../device/adc/adc.c **** 	INT		i;
 211:../device/adc/adc.c **** 
 212:../device/adc/adc.c **** 	if( unit >= DEV_ADC_UNITNM) return E_PAR;
 428                             		.loc 1 212 4
 429 023f ED A5 12                		mov.L	72[r10], r5
 430 0242 61 15                   		cmp	#1, r5
 431 0244 25 08                   		bleu	.L37
 432                             		.loc 1 212 37 discriminator 1
 433 0246 FB 56 EF                		mov.L	#-17, r5
 434 0249 38 F5 00                		bra	.L44
 435                             	.L37:
 213:../device/adc/adc.c **** 
 214:../device/adc/adc.c **** #if TK_SUPPORT_MEMLIB
 215:../device/adc/adc.c **** 	p_dcb = (T_ADC_DCB*)Kmalloc(sizeof(T_ADC_DCB));
 436                             		.loc 1 215 22
 437 024c 66 C1                   		mov.L	#12, r1
 438 024e 05 00 00 00             		bsr	_Kmalloc
 439 0252 E7 A1 01                		mov.L	r1, 4[r10]
 216:../device/adc/adc.c **** 	if( p_dcb == NULL) return E_NOMEM;
 440                             		.loc 1 216 4
 441 0255 ED A5 01                		mov.L	4[r10], r5
 442 0258 61 05                   		cmp	#0, r5
 443 025a 1F                      		bne	.L39
 444                             		.loc 1 216 28 discriminator 1
 445 025b FB 56 DF                		mov.L	#-33, r5
 446 025e 38 E0 00                		bra	.L44
 447                             	.L39:
 217:../device/adc/adc.c **** 	dev_adc_cb[unit]	= p_dcb;
 448                             		.loc 1 217 19
 449 0261 FB 52 00 00 00 00       		mov.L	#_dev_adc_cb, r5
 450 0267 ED A4 12                		mov.L	72[r10], r4
 451 026a ED A3 01                		mov.L	4[r10], r3
 452 026d FE 24 53                		mov.L	r3, [r4,r5]
 218:../device/adc/adc.c **** #else
 219:../device/adc/adc.c **** 	p_dcb = &dev_adc_cb[unit];
 220:../device/adc/adc.c **** #endif	/* TK_SUPPORT_MEMLIB */
 221:../device/adc/adc.c **** 
 222:../device/adc/adc.c **** 	/* Device registration information */
 223:../device/adc/adc.c **** 	dmsdi.exinf	= p_dcb;
 453                             		.loc 1 223 14
 454 0270 ED A5 01                		mov.L	4[r10], r5
 455 0273 E7 A5 05                		mov.L	r5, 20[r10]
 224:../device/adc/adc.c **** 	dmsdi.drvatr	= 0;			/* Driver attributes */
 456                             		.loc 1 224 15
 457 0276 F9 A6 09 00             		mov.L	#0, 36[r10]
 225:../device/adc/adc.c **** 	dmsdi.devatr	= TDK_UNDEF;		/* Device attributes */
 458                             		.loc 1 225 15
 459 027a F9 A6 0A 00             		mov.L	#0, 40[r10]
 226:../device/adc/adc.c **** 	dmsdi.nsub	= 0;			/* Number of subunits */
 460                             		.loc 1 226 13
 461 027e F9 A6 0B 00             		mov.L	#0, 44[r10]
 227:../device/adc/adc.c **** 	dmsdi.blksz	= 1;			/* Unique data block size (-1 = unknown) */
 462                             		.loc 1 227 14
 463 0282 F9 A6 0C 01             		mov.L	#1, 48[r10]
 228:../device/adc/adc.c **** 	dmsdi.openfn	= dev_adc_openfn;
 464                             		.loc 1 228 15
 465 0286 F9 A2 0D 00 00 00 00    		mov.L	#_dev_adc_openfn, 52[r10]
 229:../device/adc/adc.c **** 	dmsdi.closefn	= dev_adc_closefn;
 466                             		.loc 1 229 16
 467 028d F9 A2 0E 00 00 00 00    		mov.L	#_dev_adc_closefn, 56[r10]
 230:../device/adc/adc.c **** 	dmsdi.readfn	= dev_adc_readfn;
 468                             		.loc 1 230 15
 469 0294 F9 A2 0F 00 00 00 00    		mov.L	#_dev_adc_readfn, 60[r10]
 231:../device/adc/adc.c **** 	dmsdi.writefn	= dev_adc_writefn;
 470                             		.loc 1 231 16
 471 029b F9 A2 10 00 00 00 00    		mov.L	#_dev_adc_writefn, 64[r10]
 232:../device/adc/adc.c **** 	dmsdi.eventfn	= dev_adc_eventfn;
 472                             		.loc 1 232 16
 473 02a2 F9 A2 11 00 00 00 00    		mov.L	#_dev_adc_eventfn, 68[r10]
 233:../device/adc/adc.c **** 	
 234:../device/adc/adc.c **** 	knl_strcpy( (char*)dmsdi.devnm, DEVCNF_ADC_DEVNAME);
 474                             		.loc 1 234 2
 475 02a9 71 A5 14                		add	#20, r10, r5
 476 02ac 62 45                   		add	#4, r5
 477 02ae FB 22 00 00 00 00       		mov.L	#.LC0, r2
 478 02b4 EF 51                   		mov.L	r5, r1
 479 02b6 05 00 00 00             		bsr	_knl_strcpy
 235:../device/adc/adc.c **** 	i = knl_strlen(DEVCNF_ADC_DEVNAME);
 480                             		.loc 1 235 6
 481 02ba FB 12 00 00 00 00       		mov.L	#.LC0, r1
 482 02c0 05 00 00 00             		bsr	_knl_strlen
 483 02c4 E7 A1 02                		mov.L	r1, 8[r10]
 236:../device/adc/adc.c **** 	dmsdi.devnm[i] = (UB)('a' + unit);
 484                             		.loc 1 236 19
 485 02c7 ED A5 12                		mov.L	72[r10], r5
 486 02ca 71 55 61                		add	#0x61, r5
 487 02cd CF 54                   		mov.B	r5, r4
 488                             		.loc 1 236 17
 489 02cf 71 A5 18                		add	#24, r10, r5
 490 02d2 06 89 A5 02             		add	8[r10].L, r5
 491 02d6 C3 54                   		mov.B	r4, [r5]
 237:../device/adc/adc.c **** 	dmsdi.devnm[i+1] = 0;
 492                             		.loc 1 237 15
 493 02d8 ED A5 02                		mov.L	8[r10], r5
 494 02db 62 15                   		add	#1, r5
 495                             		.loc 1 237 19
 496 02dd 4B A5                   		add	r10, r5
 497 02df 3C D8 00                		mov.B	#0, 24[r5]
 238:../device/adc/adc.c **** 
 239:../device/adc/adc.c **** 	err = msdi_def_dev( &dmsdi, &idev, &p_msdi);
 498                             		.loc 1 239 8
 499 02e2 71 A3 10                		add	#16, r10, r3
 500 02e5 71 A4 0C                		add	#12, r10, r4
 501 02e8 71 A5 14                		add	#20, r10, r5
 502 02eb EF 42                   		mov.L	r4, r2
 503 02ed EF 51                   		mov.L	r5, r1
 504 02ef 05 00 00 00             		bsr	_msdi_def_dev
 505 02f3 E3 A1                   		mov.L	r1, [r10]
 240:../device/adc/adc.c **** 	if(err != E_OK) goto err_2;
 506                             		.loc 1 240 4
 507 02f5 EC A5                   		mov.L	[r10], r5
 508 02f7 61 05                   		cmp	#0, r5
 509 02f9 21 3B                   		bne	.L46
 241:../device/adc/adc.c **** 
 242:../device/adc/adc.c **** 	p_dcb->unit	= unit;
 510                             		.loc 1 242 14
 511 02fb ED A5 01                		mov.L	4[r10], r5
 512 02fe ED A4 12                		mov.L	72[r10], r4
 513 0301 E3 54                   		mov.L	r4, [r5]
 243:../device/adc/adc.c **** 	p_dcb->evtmbfid = idev.evtmbfid;
 514                             		.loc 1 243 24
 515 0303 ED A4 03                		mov.L	12[r10], r4
 516                             		.loc 1 243 18
 517 0306 ED A5 01                		mov.L	4[r10], r5
 518 0309 A0 D4                   		mov.L	r4, 8[r5]
 244:../device/adc/adc.c **** 
 245:../device/adc/adc.c **** 	/* Low-level device initialization */
 246:../device/adc/adc.c **** 	err = (ER)dev_adc_llinit( get_dcb_ptr(unit));
 519                             		.loc 1 246 12
 520 030b FB 52 00 00 00 00       		mov.L	#_dev_adc_cb, r5
 521 0311 ED A4 12                		mov.L	72[r10], r4
 522 0314 FE 64 55                		mov.L	[r4,r5], r5
 523 0317 EF 51                   		mov.L	r5, r1
 524 0319 05 00 00 00             		bsr	_dev_adc_llinit
 525 031d E3 A1                   		mov.L	r1, [r10]
 247:../device/adc/adc.c **** 	if(err != E_OK) goto err_1;
 526                             		.loc 1 247 4
 527 031f EC A5                   		mov.L	[r10], r5
 528 0321 61 05                   		cmp	#0, r5
 529 0323 1D                      		bne	.L47
 248:../device/adc/adc.c **** 
 249:../device/adc/adc.c **** 	return E_OK;
 530                             		.loc 1 249 9
 531 0324 66 05                   		mov.L	#0, r5
 532 0326 2E 18                   		bra	.L44
 533                             	.L47:
 247:../device/adc/adc.c **** 	if(err != E_OK) goto err_1;
 534                             		.loc 1 247 18
 535 0328 03                      		nop
 536                             	.L43:
 250:../device/adc/adc.c **** 
 251:../device/adc/adc.c **** err_1:
 252:../device/adc/adc.c **** 	msdi_del_dev(p_msdi);
 537                             		.loc 1 252 2
 538 0329 ED A5 04                		mov.L	16[r10], r5
 539 032c EF 51                   		mov.L	r5, r1
 540 032e 05 00 00 00             		bsr	_msdi_del_dev
 541 0332 2E 03                   		bra	.L41
 542                             	.L46:
 240:../device/adc/adc.c **** 
 543                             		.loc 1 240 18
 544 0334 03                      		nop
 545                             	.L41:
 253:../device/adc/adc.c **** err_2:
 254:../device/adc/adc.c **** 	Kfree(p_dcb);
 546                             		.loc 1 254 2
 547 0335 ED A1 01                		mov.L	4[r10], r1
 548 0338 05 00 00 00             		bsr	_Kfree
 255:../device/adc/adc.c **** 	return err;
 549                             		.loc 1 255 9
 550 033c EC A5                   		mov.L	[r10], r5
 551                             		.balign 8,3,1
 552                             	.L44:
 256:../device/adc/adc.c **** }
 553                             		.loc 1 256 1 discriminator 1
 554 033e EF 51                   		mov.L	r5, r1
 555 0340 3F AA 14                		rtsd	#80, r10-r10
 556                             	.LFE14:
 762                             	.Letext0:
 763                             		.file 2 "D:\\tkernel_dev\\mtk3_bsp\\dev_bsp_b2_rskrx65n\\include/tk/typedef.h"
 764                             		.file 3 "D:\\tkernel_dev\\mtk3_bsp\\dev_bsp_b2_rskrx65n\\include/tk/syscall.h"
 765                             		.file 4 "D:\\tkernel_dev\\mtk3_bsp\\dev_bsp_b2_rskrx65n\\include/tk/syslib.h"
 766                             		.file 5 "../device/adc/../common/drvif/msdrvif.h"
 767                             		.file 6 "../device/adc/adc.h"
